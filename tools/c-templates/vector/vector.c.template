#include "${header_name}"

#include <assert.h>
#include <stdlib.h>

static const unsigned INITIAL_CAPACITY = 32;

/* The following two declarations are necessary to avoid linker errors
   when the ${prefix}_get and ${prefix}_set functions are not
   inlined. */
extern inline ${element_type}
${prefix}_get (${vector_type} *vec, unsigned idx);
extern inline void
${prefix}_set (${vector_type} *vec, unsigned idx, ${element_type} val);

${vector_type} *
${prefix}_create ()
{
    return ${prefix}_create_with_capacity(INITIAL_CAPACITY);
}

${vector_type} *
${prefix}_create_with_capacity (unsigned num_elems)
{
    num_elems = num_elems > 0 ? num_elems : INITIAL_CAPACITY;
    ${vector_type} *vec = (${vector_type} *)
        malloc (sizeof(${vector_type}));
    vec->store = (${element_type} *)
        malloc (num_elems * sizeof(${element_type}));
    vec->capacity = num_elems;
    vec->num_elems = 0;
    ${prefix}_check_invariants (vec);
    return vec;
}

void
${prefix}_destroy (${vector_type} *vec)
{
    if (vec == NULL) return;

    ${prefix}_check_invariants (vec);
    free (vec->store);
    free (vec);
}

unsigned
${prefix}_get_num_elems (${vector_type} *vec)
{
    ${prefix}_check_invariants (vec);
    return vec->num_elems;
}

unsigned
${prefix}_get_capacity (${vector_type} *vec)
{
    ${prefix}_check_invariants (vec);
    return vec->capacity;
}

static void
double_vector_size (${vector_type} *vec)
{
    ${prefix}_check_invariants (vec);
    unsigned new_capacity = vec->capacity * 2;
    vec->store = (${element_type} *)
        realloc (vec->store, new_capacity * sizeof(${element_type}));
    vec->capacity = new_capacity;
    ${prefix}_check_invariants (vec);
}

void
${prefix}_push_back (${vector_type} *vec, ${element_type} node)
{
    ${prefix}_check_invariants (vec);
    if (vec->num_elems == vec->capacity)
        double_vector_size (vec);
    const unsigned idx = vec->num_elems;
    vec->num_elems += 1;
    ${prefix}_set (vec, idx, node);
    ${prefix}_check_invariants (vec);
}
