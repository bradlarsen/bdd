Comp-160 Project:  Binary Decision Diagrams
Bradford Larsen
December 2010


Overview
========

I implemented a simple C library for binary decision diagrams (BDDs)
for my Comp-160 programming project.  Binary decision diagrams
represent Boolean functions compactly.  A binary decision diagram is
like a binary decision tree (BDT), but with extra properties.  In BDDs
and BDTs, each node is either labeled with a variable and has `low'
and `high' successors, or is a terminal node, representing true or
false.  BDDs include the following additional properties over BDTs:

    * For each two nodes n1 and n2, if variable(n1) = variable(n2),
      low(n1) = low(n2), and high(n1) = high(n2), then n1 = n2.

    * For each node n, low(n) != high(n).

    * For each node n, variable(n) < variable(low(n)) and
      variable(n) < variable(high(n)).

Or in other words, a BDD is a BDT where variables always occur in a
given order, and where isomorphic subgraphs are merged.

My library supports the following core BDD operations:

    * Get i'th variable --- Given a variable index i, constructs a BDD
      denoting the expression x_i

    * Logical not --- Given a BDD b, constructs a BDD denoting the
      negation of b

    * Restrict --- Given a BDD b, a variable index i, and a Boolean
      value v, constructs a BDD equivalent to b with variable x_i
      assigned value v.

    * Apply --- Given a binary operation op, which is one of {AND, OR,
      XOR, NAND, EQUIV, IMPLIES}, and two BDDs b1 and b2, constructs a
      BDD denoting b1 op b2.

    * Sat Count --- Given a BDD b, count the number of satisfying
      variable assignments.

Several other operations can be derived from these, such as
existential instantiation, universal instantiation, and composition.
I provide a test program with this submission that among other tests,
compares BDD and truth table evaluation for random Boolean expressions
of up to 8 variables.

Through this project, I gained a basic understanding of how binary
decision diagrams work, and made good progress on a BDD library
implementation that I may use for future research on BDD variable
reordering techniques.


Building and Running
====================

Synopsis
--------

There is a makefile in the top level of the directory tree.  On
linux.eecs.tufts.edu, simply type `make' at the top level directory to
build the library and test program:

    $ make

Once the build has completed, the BDD library test program can be
found in dist/build/test-hs-bdd/test-hs-bdd.

    $ ./dist/build/test-hs-bdd/test-hs-bdd

Run without any arguments to perform each test on 100 random inputs.
An optional positive integer parameter specifies the number of tests
to run.


Implementation Details
======================
The BDD library is written in C89.  Haskell bindings for the BDD
library are provided.  The test program is written in Haskell using
the QuickCheck library for randomized testing.

The BDD library implementation largely follows that described by
Andersen in his lecture notes, ``An Introduction to Binary Decision
Diagrams'':

    * Multiple BDDs share the same graph, i.e., the graph has multiple
      roots.

    * In user code, BDDs are represented as integers, which are in
      fact array indexes (although the user is not supposed to know
      this fact.)

    * The BDD graph is represented using a vector of triples and a
      hash table from triples to indexes, allowing O(1) retrieval of
      nodes by index or index by node.

    * All creation of BDD nodes is done using a make_node internal
      helper function that ensures that the BDD graph remains reduced.

Another point of interest:

    * My implementation of BDD negation and BDD restrict have time
      complexity in O(2^n).  Using dynamic programming the complexity
      could be made polynomial.  The modification would be simple to
      do, involving some simple caching code, but is left as future
      work.


Files Included in the Submission
================================
There are many files included in this submission:

    README                        This file
    bdd97.ps                      Andersen's ``An Introduction to Binary
                                      Decision Diagrams''

There are many infrastructure files, e.g., which specify how to build
things, which are not interesting:

    Makefile                      A simple wrapper for the cabal commands
    Setup.hs                      Haskell Cabal setup program
    hs-bdd.cabal                  Haskell Cabal package description

The sources for the BDD library are found in the src subdirectory:

    src/bdd.h                     The public library interface
    src/node.h                    BDD node definition
    src/bdd_pair.h                BDD pair definition
    src/bdd_impl.h                Internal BDD library interface
    src/bdd_impl.c                Internal BDD library definitions
    src/bdd_accessors.c           Num. vars. / num. nodes accessors
    src/bdd_create_destroy.c      Initialization and destruction code
    src/bdd_ops.c                 Implementation of BDD operations, e.g.,
                                      apply and restrict
    src/node_vec.h                BDD node vector interface
    src/node_vec.c                BDD node vector implementation
    src/hash_pair.h               Integer pair hash function
    src/bdd_pair_ht.h             BDD pairs to BDDs hash table interface
    src/bdd_pair_ht.c             Hash table from BDD pairs to BDDs
    src/node_ht.h                 BDD node to BDD hash table interface
    src/node_ht.c                 BDD node to BDD hash table implementation

A few files are for the Haskell bindings and test program:

    BDD/Raw.hsc                   Haskell bindings to the C library
    Test.hs                       The test program
    BoolExpr.hs                   Boolean expressions & random generation
    QuickCheckProperties.hs       The actual test properties
